// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getModel = `-- name: GetModel :one
select id,
       name,
       description
from models
where id = $1
`

type GetModelRow struct {
	ID          int64
	Name        string
	Description string
}

func (q *Queries) GetModel(ctx context.Context, id int64) (GetModelRow, error) {
	row := q.db.QueryRow(ctx, getModel, id)
	var i GetModelRow
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getModelHyperparameters = `-- name: GetModelHyperparameters :many
select h.id,
       h.name,
       h.description,
       h.type,
       h.default_value
from models m
         join hyperparameters h on m.id = h.model_id
where m.id = $1
`

type GetModelHyperparametersRow struct {
	ID           int64
	Name         string
	Description  string
	Type         string
	DefaultValue []byte
}

func (q *Queries) GetModelHyperparameters(ctx context.Context, id int64) ([]GetModelHyperparametersRow, error) {
	rows, err := q.db.Query(ctx, getModelHyperparameters, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetModelHyperparametersRow
	for rows.Next() {
		var i GetModelHyperparametersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Type,
			&i.DefaultValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelProblem = `-- name: GetModelProblem :one
select p.id,
       p.name,
       p.description,
       array_agg(me.id)          as metric_ids,
       array_agg(me.name)        as metric_names,
       array_agg(me.description) as metric_descriptions
from models m
         join problems p on m.problem_id = p.id
         join problem_metrics pm on p.id = pm.problem_id
         join metrics me on pm.metric_id = me.id
where m.id = $1
group by (p.id, p.name, p.description)
`

type GetModelProblemRow struct {
	ID                 int64
	Name               string
	Description        string
	MetricIds          []int64
	MetricNames        []string
	MetricDescriptions []string
}

func (q *Queries) GetModelProblem(ctx context.Context, id int64) (GetModelProblemRow, error) {
	row := q.db.QueryRow(ctx, getModelProblem, id)
	var i GetModelProblemRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MetricIds,
		&i.MetricNames,
		&i.MetricDescriptions,
	)
	return i, err
}

const getModels = `-- name: GetModels :many
select id,
       name,
       description,
       count(1) over () as count
from models
where name like $1
  and (problem_id = $4 or $4 = 0)
order by created_at desc
limit $2 offset $3
`

type GetModelsParams struct {
	Name      string
	Limit     int64
	Offset    int64
	ProblemID int64
}

type GetModelsRow struct {
	ID          int64
	Name        string
	Description string
	Count       int64
}

func (q *Queries) GetModels(ctx context.Context, arg GetModelsParams) ([]GetModelsRow, error) {
	rows, err := q.db.Query(ctx, getModels,
		arg.Name,
		arg.Limit,
		arg.Offset,
		arg.ProblemID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetModelsRow
	for rows.Next() {
		var i GetModelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProblems = `-- name: GetProblems :many
select id,
       name,
       description,
       count(1) over () as count
from problems
where name like $1
order by created_at desc
limit $2 offset $3
`

type GetProblemsParams struct {
	Name   string
	Limit  int64
	Offset int64
}

type GetProblemsRow struct {
	ID          int64
	Name        string
	Description string
	Count       int64
}

func (q *Queries) GetProblems(ctx context.Context, arg GetProblemsParams) ([]GetProblemsRow, error) {
	rows, err := q.db.Query(ctx, getProblems, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProblemsRow
	for rows.Next() {
		var i GetProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrainedModel = `-- name: GetTrainedModel :one
select tm.id,
       tm.name,
       tm.description,
       tm.model_training_status,
       m.id          as model_id,
       m.name        as model_name,
       p.id          as problem_id,
       p.description as problem_description,
       p.name        as problem_name,
       tm.training_dataset_id,
       d.name        as training_dataset_name,
       tm.created_at,
       tm.launch_id,
       tm.target_column
from trained_models tm
         join models m on tm.model_id = m.id
         join problems p on m.problem_id = p.id
         join datasets d on d.id = tm.training_dataset_id
where tm.id = $1
`

type GetTrainedModelRow struct {
	ID                  int64
	Name                string
	Description         string
	ModelTrainingStatus ModelTrainingStatus
	ModelID             int64
	ModelName           string
	ProblemID           int64
	ProblemDescription  string
	ProblemName         string
	TrainingDatasetID   int64
	TrainingDatasetName string
	CreatedAt           pgtype.Timestamptz
	LaunchID            int64
	TargetColumn        string
}

func (q *Queries) GetTrainedModel(ctx context.Context, id int64) (GetTrainedModelRow, error) {
	row := q.db.QueryRow(ctx, getTrainedModel, id)
	var i GetTrainedModelRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ModelTrainingStatus,
		&i.ModelID,
		&i.ModelName,
		&i.ProblemID,
		&i.ProblemDescription,
		&i.ProblemName,
		&i.TrainingDatasetID,
		&i.TrainingDatasetName,
		&i.CreatedAt,
		&i.LaunchID,
		&i.TargetColumn,
	)
	return i, err
}

const getTrainedModels = `-- name: GetTrainedModels :many
select tm.id,
       tm.name,
       tm.description,
       tm.model_training_status,
       m.id             as model_id,
       m.name           as model_name,
       p.name           as problem_name,
       tm.training_dataset_id as training_dataset_id,
       d.name           as training_dataset_name,
       tm.created_at,
       tm.launch_id,
       count(1) over () as count
from trained_models tm
         join models m on tm.model_id = m.id
         join problems p on m.problem_id = p.id
         join datasets d on d.id = tm.training_dataset_id
where tm.name like $1
  and (tm.model_id = $4 or $4 = 0)
order by created_at desc
limit $2 offset $3
`

type GetTrainedModelsParams struct {
	Name    string
	Limit   int64
	Offset  int64
	ModelID int64
}

type GetTrainedModelsRow struct {
	ID                  int64
	Name                string
	Description         string
	ModelTrainingStatus ModelTrainingStatus
	ModelID             int64
	ModelName           string
	ProblemName         string
	TrainingDatasetID   int64
	TrainingDatasetName string
	CreatedAt           pgtype.Timestamptz
	LaunchID            int64
	Count               pgtype.Int8
}

func (q *Queries) GetTrainedModels(ctx context.Context, arg GetTrainedModelsParams) ([]GetTrainedModelsRow, error) {
	rows, err := q.db.Query(ctx, getTrainedModels,
		arg.Name,
		arg.Limit,
		arg.Offset,
		arg.ModelID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTrainedModelsRow
	for rows.Next() {
		var i GetTrainedModelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ModelTrainingStatus,
			&i.ModelID,
			&i.ModelName,
			&i.ProblemName,
			&i.TrainingDatasetID,
			&i.TrainingDatasetName,
			&i.CreatedAt,
			&i.LaunchID,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
