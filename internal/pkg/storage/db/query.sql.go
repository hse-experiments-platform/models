// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package db

import (
	"context"
)

const getModel = `-- name: GetModel :one
select id,
       name,
       description
from models
where id = $1
`

type GetModelRow struct {
	ID          int64
	Name        string
	Description string
}

func (q *Queries) GetModel(ctx context.Context, id int64) (GetModelRow, error) {
	row := q.db.QueryRow(ctx, getModel, id)
	var i GetModelRow
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getModelHyperparameters = `-- name: GetModelHyperparameters :many
select h.id,
       h.name,
       h.description,
       h.type,
       h.default_value
from models m
         join hyperparameters h on m.id = h.model_id
where m.id = $1
`

type GetModelHyperparametersRow struct {
	ID           int64
	Name         string
	Description  string
	Type         string
	DefaultValue []byte
}

func (q *Queries) GetModelHyperparameters(ctx context.Context, id int64) ([]GetModelHyperparametersRow, error) {
	rows, err := q.db.Query(ctx, getModelHyperparameters, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetModelHyperparametersRow
	for rows.Next() {
		var i GetModelHyperparametersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Type,
			&i.DefaultValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelProblem = `-- name: GetModelProblem :one
select p.id,
       p.name,
       p.description,
       array_agg(me.id)          as metric_ids,
       array_agg(me.name)        as metric_names,
       array_agg(me.description) as metric_descriptions
from models m
         join problems p on m.problem_id = p.id
         join problem_metrics pm on p.id = pm.problem_id
         join metrics me on pm.metric_id = me.id
where m.id = $1
group by (p.id, p.name, p.description)
`

type GetModelProblemRow struct {
	ID                 int64
	Name               string
	Description        string
	MetricIds          []int64
	MetricNames        []string
	MetricDescriptions []string
}

func (q *Queries) GetModelProblem(ctx context.Context, id int64) (GetModelProblemRow, error) {
	row := q.db.QueryRow(ctx, getModelProblem, id)
	var i GetModelProblemRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MetricIds,
		&i.MetricNames,
		&i.MetricDescriptions,
	)
	return i, err
}

const getModels = `-- name: GetModels :many
select id,
       name,
       description,
       count(1) over () as count
from models
where name like $1 and (problem_id = $4 or $4 = 0)
order by created_at desc
limit $2 offset $3
`

type GetModelsParams struct {
	Name      string
	Limit     int64
	Offset    int64
	ProblemID int64
}

type GetModelsRow struct {
	ID          int64
	Name        string
	Description string
	Count       int64
}

func (q *Queries) GetModels(ctx context.Context, arg GetModelsParams) ([]GetModelsRow, error) {
	rows, err := q.db.Query(ctx, getModels,
		arg.Name,
		arg.Limit,
		arg.Offset,
		arg.ProblemID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetModelsRow
	for rows.Next() {
		var i GetModelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProblems = `-- name: GetProblems :many
select id,
       name,
       description,
       count(1) over () as count
from problems
where name like $1
order by created_at desc
limit $2 offset $3
`

type GetProblemsParams struct {
	Name   string
	Limit  int64
	Offset int64
}

type GetProblemsRow struct {
	ID          int64
	Name        string
	Description string
	Count       int64
}

func (q *Queries) GetProblems(ctx context.Context, arg GetProblemsParams) ([]GetProblemsRow, error) {
	rows, err := q.db.Query(ctx, getProblems, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProblemsRow
	for rows.Next() {
		var i GetProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
