// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createHyperparameters = `-- name: CreateHyperparameters :exec
insert into hyperparameters (name, description, type, default_value, model_id)
select unnest($1::text[]),
       unnest($2::text[]),
       unnest($3::text[]),
       unnest($4::text[]),
       $5
`

type CreateHyperparametersParams struct {
	Names         []string
	Descriptions  []string
	Types         []string
	DefaultValues []string
	ModelID       pgtype.Int8
}

func (q *Queries) CreateHyperparameters(ctx context.Context, arg CreateHyperparametersParams) error {
	_, err := q.db.Exec(ctx, createHyperparameters,
		arg.Names,
		arg.Descriptions,
		arg.Types,
		arg.DefaultValues,
		arg.ModelID,
	)
	return err
}

const createModel = `-- name: CreateModel :one
insert into models (name, description, problem_id)
values ($1, $2, (select id from problems where name = $3))
returning id
`

type CreateModelParams struct {
	Name        pgtype.Text
	Description pgtype.Text
	Problem     pgtype.Text
}

func (q *Queries) CreateModel(ctx context.Context, arg CreateModelParams) (int64, error) {
	row := q.db.QueryRow(ctx, createModel, arg.Name, arg.Description, arg.Problem)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createModelMetrics = `-- name: CreateModelMetrics :exec
insert into metrics (metric_name, model_id)
select unnest($1::text[]), $2
`

type CreateModelMetricsParams struct {
	MetricNames []string
	ModelID     int64
}

func (q *Queries) CreateModelMetrics(ctx context.Context, arg CreateModelMetricsParams) error {
	_, err := q.db.Exec(ctx, createModelMetrics, arg.MetricNames, arg.ModelID)
	return err
}

const getAllModels = `-- name: GetAllModels :many
select m.id,
       m.name,
       m.description,
       p.name                                         as problem_name,
       array_remove(h.name, null)          as hyperparameter_names,
       array_remove(h.description, null)   as hyperparameter_descriptions,
       array_remove(h.type, null)          as hyperparameter_types,
       array_remove(h.default_value, null) as hyperparameter_default_values,
       array_remove(m2.metric_name, null)  as metric_names
from models m
         join problems p on m.problem_id = p.id
         cross join lateral (select array_agg(h.name)          as name,
                                    array_agg(h.description)   as description,
                                    array_agg(h.type)          as "type",
                                    array_agg(h.default_value) as default_value
                             from hyperparameters h
                             where m.id = h.model_id) as h
         cross join lateral (select array_agg(m2.metric_name)          as metric_name
                             from metrics m2
                             where m.id = m2.model_id) as m2
`

type GetAllModelsRow struct {
	ID                          int64
	Name                        string
	Description                 string
	ProblemName                 string
	HyperparameterNames         []string
	HyperparameterDescriptions  []string
	HyperparameterTypes         []string
	HyperparameterDefaultValues []string
	MetricNames                 []string
}

func (q *Queries) GetAllModels(ctx context.Context) ([]GetAllModelsRow, error) {
	rows, err := q.db.Query(ctx, getAllModels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllModelsRow
	for rows.Next() {
		var i GetAllModelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ProblemName,
			&i.HyperparameterNames,
			&i.HyperparameterDescriptions,
			&i.HyperparameterTypes,
			&i.HyperparameterDefaultValues,
			&i.MetricNames,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModel = `-- name: GetModel :one
select id,
       name,
       description
from models
where id = $1
`

type GetModelRow struct {
	ID          int64
	Name        string
	Description string
}

func (q *Queries) GetModel(ctx context.Context, id int64) (GetModelRow, error) {
	row := q.db.QueryRow(ctx, getModel, id)
	var i GetModelRow
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getModelHyperparameters = `-- name: GetModelHyperparameters :many
select h.id,
       h.name,
       h.description,
       h.type,
       h.default_value
from models m
         join hyperparameters h on m.id = h.model_id
where m.id = $1
`

type GetModelHyperparametersRow struct {
	ID           int64
	Name         string
	Description  string
	Type         string
	DefaultValue string
}

func (q *Queries) GetModelHyperparameters(ctx context.Context, id int64) ([]GetModelHyperparametersRow, error) {
	rows, err := q.db.Query(ctx, getModelHyperparameters, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetModelHyperparametersRow
	for rows.Next() {
		var i GetModelHyperparametersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Type,
			&i.DefaultValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModelProblem = `-- name: GetModelProblem :one
select p.id,
       p.name,
       p.description,
       array_agg(me.id)          as metric_ids,
       array_agg(me.metric_name) as metric_names
from models m
         join problems p on m.problem_id = p.id
         join metrics me on m.id = me.model_id
where m.id = $1
group by (p.id, p.name, p.description)
`

type GetModelProblemRow struct {
	ID          int64
	Name        string
	Description string
	MetricIds   []int64
	MetricNames []string
}

func (q *Queries) GetModelProblem(ctx context.Context, id int64) (GetModelProblemRow, error) {
	row := q.db.QueryRow(ctx, getModelProblem, id)
	var i GetModelProblemRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MetricIds,
		&i.MetricNames,
	)
	return i, err
}

const getModels = `-- name: GetModels :many
select id,
       name,
       description,
       count(1) over () as count
from models
where name like $1
  and (problem_id = $4 or $4 = 0)
order by created_at desc
limit $2 offset $3
`

type GetModelsParams struct {
	Name      string
	Limit     int64
	Offset    int64
	ProblemID int64
}

type GetModelsRow struct {
	ID          int64
	Name        string
	Description string
	Count       int64
}

func (q *Queries) GetModels(ctx context.Context, arg GetModelsParams) ([]GetModelsRow, error) {
	rows, err := q.db.Query(ctx, getModels,
		arg.Name,
		arg.Limit,
		arg.Offset,
		arg.ProblemID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetModelsRow
	for rows.Next() {
		var i GetModelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProblems = `-- name: GetProblems :many
select id,
       name,
       description,
       count(1) over () as count
from problems
where name like $1
order by created_at desc
limit $2 offset $3
`

type GetProblemsParams struct {
	Name   string
	Limit  int64
	Offset int64
}

type GetProblemsRow struct {
	ID          int64
	Name        string
	Description string
	Count       int64
}

func (q *Queries) GetProblems(ctx context.Context, arg GetProblemsParams) ([]GetProblemsRow, error) {
	rows, err := q.db.Query(ctx, getProblems, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProblemsRow
	for rows.Next() {
		var i GetProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrainedModel = `-- name: GetTrainedModel :one
select tm.id,
       tm.name,
       tm.description,
       tm.model_training_status,
       m.id          as model_id,
       m.name        as model_name,
       p.id          as problem_id,
       p.description as problem_description,
       p.name        as problem_name,
       tm.training_dataset_id,
       d.name        as training_dataset_name,
       tm.created_at,
       tm.launch_id,
       tm.target_column
from trained_models tm
         join models m on tm.model_id = m.id
         join problems p on m.problem_id = p.id
         join datasets d on d.id = tm.training_dataset_id
where tm.id = $1
`

type GetTrainedModelRow struct {
	ID                  int64
	Name                string
	Description         string
	ModelTrainingStatus ModelTrainingStatus
	ModelID             int64
	ModelName           string
	ProblemID           int64
	ProblemDescription  string
	ProblemName         string
	TrainingDatasetID   int64
	TrainingDatasetName string
	CreatedAt           pgtype.Timestamptz
	LaunchID            int64
	TargetColumn        string
}

func (q *Queries) GetTrainedModel(ctx context.Context, id int64) (GetTrainedModelRow, error) {
	row := q.db.QueryRow(ctx, getTrainedModel, id)
	var i GetTrainedModelRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ModelTrainingStatus,
		&i.ModelID,
		&i.ModelName,
		&i.ProblemID,
		&i.ProblemDescription,
		&i.ProblemName,
		&i.TrainingDatasetID,
		&i.TrainingDatasetName,
		&i.CreatedAt,
		&i.LaunchID,
		&i.TargetColumn,
	)
	return i, err
}

const getTrainedModels = `-- name: GetTrainedModels :many
select tm.id,
       tm.name,
       tm.description,
       tm.model_training_status,
       m.id                   as model_id,
       m.name                 as model_name,
       p.name                 as problem_name,
       tm.training_dataset_id as training_dataset_id,
       d.name                 as training_dataset_name,
       tm.created_at,
       tm.launch_id,
       count(1) over ()       as count
from trained_models tm
         join models m on tm.model_id = m.id
         join problems p on m.problem_id = p.id
         join datasets d on d.id = tm.training_dataset_id
where tm.name like $1
  and (tm.model_id = $4 or $4 = 0)
order by created_at desc
limit $2 offset $3
`

type GetTrainedModelsParams struct {
	Name    string
	Limit   int64
	Offset  int64
	ModelID int64
}

type GetTrainedModelsRow struct {
	ID                  int64
	Name                string
	Description         string
	ModelTrainingStatus ModelTrainingStatus
	ModelID             int64
	ModelName           string
	ProblemName         string
	TrainingDatasetID   int64
	TrainingDatasetName string
	CreatedAt           pgtype.Timestamptz
	LaunchID            int64
	Count               pgtype.Int8
}

func (q *Queries) GetTrainedModels(ctx context.Context, arg GetTrainedModelsParams) ([]GetTrainedModelsRow, error) {
	rows, err := q.db.Query(ctx, getTrainedModels,
		arg.Name,
		arg.Limit,
		arg.Offset,
		arg.ModelID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTrainedModelsRow
	for rows.Next() {
		var i GetTrainedModelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ModelTrainingStatus,
			&i.ModelID,
			&i.ModelName,
			&i.ProblemName,
			&i.TrainingDatasetID,
			&i.TrainingDatasetName,
			&i.CreatedAt,
			&i.LaunchID,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
